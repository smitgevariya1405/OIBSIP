# -*- coding: utf-8 -*-
"""Unemployment_Analysis_with_Python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WKM_ppo-1wO1hWDazTkv9V2vEVK9osoT
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import calendar
import datetime as dt

import warnings
warnings.filterwarnings("ignore")
# %matplotlib inline

df=pd.read_csv("Unemployment_in_India.csv")

df.head()

print("no of rows:",df.shape[0])
print("no of columns:",df.shape[1])

df.info()

dup=df.duplicated().sum()
dup

df.isnull().sum()

sns.heatmap(df.isnull(),cbar=False)

df.columns

df.describe(include='all').round(2)

for i in df.columns.tolist():
  print("no of unique values in",i,"is",df[i].nunique())

df.columns = ['States', 'Date', 'Frequency', 'Estimated Unemployment Rate', 'Estimated Employed', 'Estimated Labour Participation Rate', 'Region']

df['Frequency']=df['Frequency'].astype('category')
df['region']=df['Region'].astype('category')

# Convert the 'Date' column to datetime format, specifying 'dayfirst' to handle date formats with day first

df['Date']=pd.to_datetime(df['Date'],dayfirst=True)

## Extract the month from the 'Date' column and create a new 'Month' column

df['Month']=df['Date'].dt.month

#creating a new column in the DataFrame called ‘Month_int’, which is the ‘Month’ column with all non-NaN values converted to integers.
#So, in simple words, this line of code is saying: “Create a new column in my data table that is a copy of the ‘Month’ column, but change all the non-empty values to integers.”

df['Month_int'] = df['Month'].apply(lambda x: int(x) if pd.notna(x) else x)

df.drop(columns='Month',inplace=True)
# Drop the 'Month' column from the DataFrame

df_ld=df.copy()
# Lets create a copy of the dataset for the data of during lockdown period

df=df.dropna()
# Drop all the missing values from 'df' dataset

mask=(df['Date']>='2019-05-31') & (df['Date']<='2020-03-31')

df=df.loc[mask]
# Use the mask to select and keep only the rows that meet the date range criteria
df

mask1=(df_ld['Date']>='2020-04-30')
df_ld=df_ld.loc[mask1]
df_ld

plt.figure(figsize=(14,5))
plt.subplot(1,2,2)

#1: This is the number of rows in the figure. In this case, there is only one row.
#2: This is the number of columns in the figure. In this case, there are two columns, meaning there will be two subplots side by side.
#2: This is the index of the current subplot. The subplots are numbered from left to right and top to bottom, starting from 1. In this case, 2 means that the current subplot is the second one, which will be on the right side.

sns.barplot(x='Region',y='Estimated Unemployment Rate',data=df)
plt.xlabel('Region',fontsize=12)
plt.ylabel('Estimated Unemployment Rate',fontsize=12)
plt.title("Estimated Unemployment Rate before Lockdown",fontsize=16)

plt.subplot(1,2,2)
cols=['red','yellow']
sns.barplot(x="Region",y="Estimated Unemployment Rate",data=df_ld,palette=cols)
plt.xlabel("Region",fontsize=12)
plt.ylabel("Estimated Unemployment Rate",fontsize=12)
plt.title("Estimated Unemployment Rate during lockdown",fontsize=15)
plt.show()

plt.figure(figsize=(25,8))
plt.subplot(1,2,1)
plt.title("state wise Estimated Unemployment Rate Before lockdown",fontsize=15)
sns.swarmplot(y="States", x="Estimated Unemployment Rate", data=df, size=8,marker='*')
plt.xlabel("Estimated Unemployment Rate  ",fontsize=12)
plt.ylabel("States",fontsize=12)
plt.show()

plt.subplot(1,2,2)
plt.title("State wise Estimated Unemployment Rate during lockdown ",fontsize=15)
sns.swarmplot(x="Estimated Unemployment Rate",y="States",data=df,size=4)
plt.xlabel("Estimated Unemployment Rate",fontsize=12)
plt.ylabel("States",fontsize=12)
plt.show()


#The swarmplot() function is used to draw a categorical scatterplot with non-overlapping points.

#different diff palette:
# deep, muted, bright, pastel, dark, colorblind
plt.figure(figsize=(25,8))
plt.subplot(1,2,1)
plt.title("Estimated Unemployment Rate Before Lockdown",fontsize=16)
sns.barplot(data=df_ld.sort_values(by='Estimated Unemployment Rate',ascending=False),x="States",y="Estimated Unemployment Rate",palette="magma")
#data=df.sort_values(by='Estimated Unemployment Rate', ascending=False): This specifies the DataFrame df as the source of data, sorted by the ‘Estimated Unemployment Rate’ column in descending order.
plt.xticks(rotation=90)
#The xticks() function is used to get or set the current tick locations and labels of the x-axis. Here, it’s being used to rotate the x-axis labels by 90 degrees. This is often done to prevent the labels from overlapping when they are long or numerous.
plt.xlabel('States',fontsize=12)
plt.ylabel('Estimated Unemployment Rate',fontsize=12)
plt.show()

plt.figure(figsize=(27,10))
plt.subplot(1,2,2)
plt.title("Estimated Unemployment Rate During Lockdown",fontsize=16)
sns.barplot(data=df_ld.sort_values(by='Estimated Unemployment Rate',ascending=False),x="States",y="Estimated Unemployment Rate",palette="deep")
plt.xticks(rotation=90)
plt.xlabel("States",fontsize=10)
plt.ylabel("Estimated Unemployment Rate",fontsize=10)
plt.show()

plt.figure(figsize=(25,8))
plt.subplot(1,2,1)
plt.title("Estimated Employed Workforce Before Lockdown",fontsize=16)
sns.barplot(data=df.sort_values(by='Estimated Employed',ascending=False),x="States",y="Estimated Employed",palette="muted")
plt.xticks(rotation=90)
plt.xlabel("States",fontsize=12)
plt.ylabel("Estimated Employed",fontsize=12)
plt.show()

plt.figure(figsize=(25,8))
plt.subplot(1,2,2)
plt.title("Estimated Employed Workforce During Lockdown",fontsize=16)
sns.barplot(data=df_ld.sort_values(by='Estimated Employed',ascending=False),x="States",y="Estimated Employed",palette="colorblind")
plt.xticks(rotation=90)
plt.xlabel("States",fontsize=12)
plt.ylabel("Estimated Employed",fontsize=12)
plt.show()

plt.figure(figsize=(25,8))
plt.subplot(1,2,1)
plt.title("Estimated Labour Participation Before Lockdown",fontsize=16)
sns.barplot(data=df.sort_values(by='Estimated Labour Participation Rate',ascending=False),x="States",y="Estimated Labour Participation Rate",palette="dark")
plt.xticks(rotation=90)
plt.xlabel("States",fontsize=12)
plt.ylabel("Estimated Labour Participation Rate",fontsize=12)
plt.show()

plt.figure(figsize=(25,8))
plt.subplot(1,2,1)
plt.title("Estimated Labour Participation During Lockdown",fontsize=16)
sns.barplot(data=df_ld.sort_values(by='Estimated Labour Participation Rate',ascending=False),x="States",y="Estimated Labour Participation Rate",palette="dark")
plt.xticks(rotation=90)
plt.xlabel("States",fontsize=12)
plt.ylabel("Estimated Labour Participation Rate",fontsize=12)
plt.show()

df1_stats=df[['Estimated Unemployment Rate','Estimated Employed', 'Estimated Labour Participation Rate']]
df2_stats=df_ld[['Estimated Unemployment Rate','Estimated Employed', 'Estimated Labour Participation Rate']]

plt.figure(figsize=(25,8))
plt.subplot(1,2,1)
plt.title("correlation  of variables before lockdown",fontsize=16)
#df1_stats.corr(): This is calculating the correlation matrix of the DataFrame df1_stats. The .corr() function computes pairwise correlation of columns, excluding NA/null values.
#annot=True: This argument allows the plot to place the data value into each cell.
#linewidths=0.1: This argument sets the width of the lines that will divide each cell.
#fmt='.2f': This argument controls string formatting for annotations. Here, it’s set to show float numbers with two decimal places.
#square=True: This argument, if set to True, will shape the cells as squares.
sns.heatmap(df1_stats.corr(),annot=True,linewidth=0.1,fmt='.2f',square=True)

plt.figure(figsize=(25,8))
plt.subplot(1,2,2)
plt.title("Correlation of Variables During Lockdown",fontsize=16)
sns.heatmap(df2_stats.corr(),annot=True,linewidth=0.2,fmt='0.2f',square=True)
plt.show()

"""Conclusion

In this data science project, we embarked on a comprehensive analysis of the unemployment rate, a critical economic indicator, with a particular focus on the unprecedented challenges brought about by the Covid-19 pandemic. Our exploratory data analysis yielded valuable insights that shed light on the dynamics of unemployment in India.

We observed a significant surge in the Estimated Unemployment Rate during the Covid-19 lockdown, underscoring the profound impact of the pandemic on the labor market.

Our state-wise analysis highlighted the states that bore the brunt of this crisis. Puducherry and Jharkhand stood out with the highest Estimated Unemployment Rates during the lockdown, while Haryana and Tripura held the top positions before the pandemic.

The transition from pre-lockdown to lockdown was marked by shifts in the states with the highest Estimated Unemployment Rates. Tripura, Haryana, and Himachal Pradesh led the rankings before the lockdown, whereas Puducherry, Jharkhand, and Bihar claimed the top spots during the lockdown.

Notably, states like Uttar Pradesh, Maharashtra, and West Bengal exhibited consistent challenges in maintaining high levels of Estimated Employed Workforce both before and during the lockdown.

Our analysis of Estimated Labour Participation Rate identified states that showed resilience in labor force participation. Telangana, Tripura, Meghalaya, and Assam topped the list before the lockdown, while Meghalaya, Telangana, Tripura, and Andhra Pradesh excelled during the lockdown.

We uncovered a robust negative correlation between Estimated Unemployment Rate and Estimated Employed, highlighting the intricate relationship between these two crucial employment indicators, both before and during the lockdown.
"""